<p align="center">
<img width="1000px" alt="DeepSeek Coder" src="pictures/logo.png">
</p>
<p align="center"><a href="https://www.deepseek.com/">[<img src="pictures/home.png" width="20px"> Homepage]</a> | <a href="https://coder.deepseek.com/">[🤖 Chat with DeepSeek Coder]</a> | <a href="https://huggingface.co/deepseek-ai">[🤗 Models Download]</a> | <a href="https://discord.gg/Tc7c45Zzu5">[Discord]</a> | <a href="https://github.com/guoday/assert/blob/main/QR.png?raw=true">[WeChat (微信)]</a></p>
<p align="center">
  <a href="https://huggingface.co/papers/2401.14196"><b>Paper Link</b>👁️</a>
</p>
<hr>

# DeepSeek-Coder - Advanced AI Code Assistant

## Table of Contents

- [Introduction](#1-introduction-of-deepseek-coder)
- [Evaluation Results](#2-evaluation-results)
- [Data Creation and Model Training](#3-procedure-of-data-creation-and-model-training)
- [How to Use](#4-how-to-use)
- [How to Fine-tune](#5-how-to-fine-tune-deepseek-coder)
- [Detailed Evaluation Results](#6-detailed-evaluation-results)
- [Installation and Setup](#installation-and-setup)
- [Project Structure](#project-structure)
- [Docker Setup](#docker-setup)
- [Deployment Guide](#deployment-guide)
- [Troubleshooting](#troubleshooting)
- [API Documentation](#api-documentation)
- [Security Considerations](#security-considerations)
- [Q&A](#7-qa)
- [Resources](#8-resources)
- [License](#9-license)
- [Citation](#10-citation)
- [Contact](#11-contact)

### 1. Introduction of DeepSeek Coder

DeepSeek Coder is composed of a series of code language models, each trained from scratch on 2T tokens, with a composition of 87% code and 13% natural language in both English and Chinese. We provide various sizes of the code model, ranging from 1B to 33B versions. Each model is pre-trained on project-level code corpus by employing a window size of 16K and an extra fill-in-the-blank task, to support project-level code completion and infilling. For coding capabilities, DeepSeek Coder achieves state-of-the-art performance among open-source code models on multiple programming languages and various benchmarks.

<p align="center">
<img src="pictures/result.png" alt="result" width="70%">
</p>

- **Massive Training Data**: Trained from scratch on 2T tokens, including 87% code and 13% linguistic data in both English and Chinese languages.

- **Highly Flexible & Scalable**: Offered in model sizes of 1B, 5.7B, 6.7B and 33B, enabling users to choose the setup most suitable for their requirements.

- **Superior Model Performance**: State-of-the-art performance among publicly available code models on HumanEval, MultiPL-E, MBPP, DS-1000, and APPS benchmarks.

- **Advanced Code Completion Capabilities**: A window size of 16K and a fill-in-the-blank task, supporting project-level code completion and infilling tasks.

#### Architecture Overview

DeepSeek-Coder uses an optimized transformer architecture specifically tuned for code understanding and generation:

```
┌───────────────────────────┐
│     DeepSeek-Coder        │
├───────────────────────────┤
│                           │
│  ┌───────────────────┐    │
│  │  Decoder Layers   │    │
│  └───────────────────┘    │
│                           │
│  ┌───────────────────┐    │
│  │ Token Embeddings  │    │
│  └───────────────────┘    │
│                           │
│  ┌───────────────────┐    │
│  │ Position Encoding │    │
│  └───────────────────┘    │
│                           │
└───────────────────────────┘
```

#### Supported Programming Languages
`['ada', 'agda', 'alloy', 'antlr', 'applescript', 'assembly', 'augeas', 'awk', 'batchfile', 'bluespec', 'c', 'c-sharp', 'clojure', 'cmake', 'coffeescript', 'common-lisp', 'cpp', 'css', 'cuda', 'dart', 'dockerfile', 'elixir', 'elm', 'emacs-lisp', 'erlang', 'f-sharp', 'fortran', 'glsl', 'go', 'groovy', 'haskell', 'html', 'idris', 'isabelle', 'java', 'java-server-pages', 'javascript', 'json', 'julia', 'jupyter-notebook', 'kotlin', 'lean', 'literate-agda', 'literate-coffeescript', 'literate-haskell', 'lua', 'makefile', 'maple', 'markdown', 'mathematica', 'matlab', 'ocaml', 'pascal', 'perl', 'php', 'powershell', 'prolog', 'protocol-buffer', 'python', 'r', 'racket', 'restructuredtext', 'rmarkdown', 'ruby', 'rust', 'sas', 'scala', 'scheme', 'shell', 'smalltalk', 'solidity', 'sparql', 'sql', 'stan', 'standard-ml', 'stata', 'systemverilog', 'tcl', 'tcsh', 'tex', 'thrift', 'typescript', 'verilog', 'vhdl', 'visual-basic', 'xslt', 'yacc', 'yaml', 'zig']`

### 2. Evaluation Results
We evaluate DeepSeek Coder on various coding-related benchmarks.
Only `pass@1` results on HumanEval (Python and Multilingual), MBPP, and DS-1000 are reported here:

<p align="center">
<img src="pictures/table.png" alt="table" width="70%">
</p>


The result shows that DeepSeek-Coder-Base-33B significantly outperforms existing open-source code LLMs. Compared with CodeLlama-34B, it leads by 7.9%, 9.3%, 10.8% and 5.9% respectively on HumanEval Python, HumanEval Multilingual, MBPP and DS-1000.
Surprisingly, our DeepSeek-Coder-Base-7B reaches the performance of CodeLlama-34B.
The DeepSeek-Coder-Instruct-33B model after instruction tuning outperforms GPT35-turbo on HumanEval and achieves comparable results with GPT35-turbo on MBPP.

More evaluation details can be found in the [Detailed Evaluation](#6-detailed-evaluation-results).


### 3. Procedure of Data Creation and Model Training

#### Data Creation

- Step 1: Collect code data from GitHub and apply the same filtering rules as [StarCoder Data](https://github.com/bigcode-project/bigcode-dataset) to filter data.
- Step 2: Parsing the dependencies of files within the same repository to rearrange the file positions based on their dependencies.
- Step 3: Concatenating dependent files to form a single example and employ repo-level minhash for deduplication.
- Step 4: Further filtering out low-quality code, such as codes with syntax errors or poor readability.

<img src="pictures/data_clean.png" alt="data_creation" width="100%">

#### Model Training

- Step 1: Initially pre-trained with a dataset consisting of 87% code, 10% code-related language (Github Markdown and StackExchange), and 3% non-code-related Chinese language. Models are pre-trained using 1.8T tokens and a 4K window size in this step.
- Step 2: Further Pre-training using an extended 16K window size on an additional 200B tokens, resulting in foundational models (**DeepSeek-Coder-Base**).
- Step 3: Instruction Fine-tuning on 2B tokens of instruction data, resulting in instruction-tuned models (**DeepSeek-Coder-Instruct**).

<img src="pictures/model_pretraining.png" alt="model_pretraining" width="100%">


### 4. How to Use
Before proceeding, you'll need to install the necessary dependencies. You can do this by running the following command:
```
pip install -r requirements.txt
```
A demo is also available on the [🤗 Hugging Face Space](https://huggingface.co/spaces/deepseek-ai/deepseek-coder-33b-instruct), and you can run the demo locally using `app.py` in the [demo](https://github.com/deepseek-ai/deepseek-coder/tree/main/demo) folder.  (Thanks to all the HF team for their support)

Here are some examples of how to use our model.

#### 1) Code Completion
```python
from transformers import AutoTokenizer, AutoModelForCausalLM
import torch
tokenizer = AutoTokenizer.from_pretrained("deepseek-ai/deepseek-coder-6.7b-base", trust_remote_code=True)
model = AutoModelForCausalLM.from_pretrained("deepseek-ai/deepseek-coder-6.7b-base", trust_remote_code=True, torch_dtype=torch.bfloat16).cuda()
input_text = "#write a quick sort algorithm"
inputs = tokenizer(input_text, return_tensors="pt").to(model.device)
outputs = model.generate(**inputs, max_length=128)
print(tokenizer.decode(outputs[0], skip_special_tokens=True))
```
This code will output the following result:
```
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[0]
    left = []
    right = []
    for i in range(1, len(arr)):
        if arr[i] < pivot:
            left.append(arr[i])
        else:
            right.append(arr[i])
    return quick_sort(left) + [pivot] + quick_sort(right)
```

#### 2) Code Insertion
```python
from transformers import AutoTokenizer, AutoModelForCausalLM
import torch
tokenizer = AutoTokenizer.from_pretrained("deepseek-ai/deepseek-coder-6.7b-base", trust_remote_code=True)
model = AutoModelForCausalLM.from_pretrained("deepseek-ai/deepseek-coder-6.7b-base", trust_remote_code=True, torch_dtype=torch.bfloat16).cuda()
input_text = """<｜fim▁begin｜>def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[0]
    left = []
    right = []
<｜fim▁hole｜>
        if arr[i] < pivot:
            left.append(arr[i])
        else:
            right.append(arr[i])
    return quick_sort(left) + [pivot] + quick_sort(right)<｜fim▁end｜>"""
inputs = tokenizer(input_text, return_tensors="pt").to(model.device)
outputs = model.generate(**inputs, max_length=128)
print(tokenizer.decode(outputs[0], skip_special_tokens=True)[len(input_text):])
```
This code will output the following result:
```
   for i in range(1, len(arr)):
```

#### 3) Chat Model Inference
```python
from transformers import AutoTokenizer, AutoModelForCausalLM
import torch
tokenizer = AutoTokenizer.from_pretrained("deepseek-ai/deepseek-coder-6.7b-instruct", trust_remote_code=True)
model = AutoModelForCausalLM.from_pretrained("deepseek-ai/deepseek-coder-6.7b-instruct", trust_remote_code=True, torch_dtype=torch.bfloat16).cuda()
messages=[
    { 'role': 'user', 'content': "write a quick sort algorithm in python."}
]
inputs = tokenizer.apply_chat_template(messages, add_generation_prompt=True, return_tensors="pt").to(model.device)
# tokenizer.eos_token_id is the id of <|EOT|> token
outputs = model.generate(inputs, max_new_tokens=512, do_sample=False, top_k=50, top_p=0.95, num_return_sequences=1, eos_token_id=tokenizer.eos_token_id)
print(tokenizer.decode(outputs[0][len(inputs[0]):], skip_special_tokens=True))
```
This code will output the following result:
```
Sure, here is a simple implementation of the Quick Sort algorithm in Python:

def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0]
        less_than_pivot = [x for x in arr[1:] if x <= pivot]
        greater_than_pivot = [x for x in arr[1:] if x > pivot]
        return quick_sort(less_than_pivot) + [pivot] + quick_sort(greater_than_pivot)

# Test the function
arr = [10, 7, 8, 9, 1, 5]
print("Original array:", arr)
print("Sorted array:", quick_sort(arr))

This code works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The pivot element is then in its final position. The process is then repeated for the sub-arrays.
```

If you don't want to use the provided API `apply_chat_template` which loads the template from `tokenizer_config.json`, you can use the following template to chat with our model. Replace the `['content']` with your instructions and the model's previous (if any) responses, then the model will generate the response to the currently given instruction.
```
You are an AI programming assistant, utilizing the DeepSeek Coder model, developed by DeepSeek Company, and you only answer questions related to computer science. For politically sensitive questions, security and privacy issues, and other non-computer science questions, you will refuse to answer.
### Instruction:
['content']
### Response:
['content']
<|EOT|>
### Instruction:
['content']
### Response:

```

#### 4) Repository Level Code Completion
```python
from transformers import AutoTokenizer, AutoModelForCausalLM
import torch
tokenizer = AutoTokenizer.from_pretrained("deepseek-ai/deepseek-coder-6.7b-base", trust_remote_code=True)
model = AutoModelForCausalLM.from_pretrained("deepseek-ai/deepseek-coder-6.7b-base", trust_remote_code=True, torch_dtype=torch.bfloat16).cuda()

input_text = """#utils.py
import torch
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score

def load_data():
    iris = datasets.load_iris()
    X = iris.data
    y = iris.target

    # Standardize the data
    scaler = StandardScaler()
    X = scaler.fit_transform(X)

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

    # Convert numpy data to PyTorch tensors
    X_train = torch.tensor(X_train, dtype=torch.float32)
    X_test = torch.tensor(X_test, dtype=torch.float32)
    y_train = torch.tensor(y_train, dtype=torch.int64)
    y_test = torch.tensor(y_test, dtype=torch.int64)

    return X_train, X_test, y_train, y_test

def evaluate_predictions(y_test, y_pred):
    return accuracy_score(y_test, y_pred)


# model.py
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset

class IrisClassifier(nn.Module):
    def __init__(self):
        super(IrisClassifier, self).__init__()
        self.fc = nn.Sequential(
            nn.Linear(4, 16),
            nn.ReLU(),
            nn.Linear(16, 3)
        )

    def forward(self, x):
        return self.fc(x)

    def train_model(self, X_train, y_train, epochs, lr, batch_size):
        criterion = nn.CrossEntropyLoss()
        optimizer = optim.Adam(self.parameters(), lr=lr)

        # Create DataLoader for batches
        dataset = TensorDataset(X_train, y_train)
        dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)

        for epoch in range(epochs):
            for batch_X, batch_y in dataloader:
                optimizer.zero_grad()
                outputs = self(batch_X)
                loss = criterion(outputs, batch_y)
                loss.backward()
                optimizer.step()

    def predict(self, X_test):
        with torch.no_grad():
            outputs = self(X_test)
            _, predicted = outputs.max(1)
        return predicted.numpy()


# main.py
from utils import load_data, evaluate_predictions
from model import IrisClassifier as Classifier

def main():
    # Model training and evaluation
"""
inputs = tokenizer(input_text, return_tensors="pt").to(model.device)
outputs = model.generate(**inputs, max_new_tokens=140)
print(tokenizer.decode(outputs[0]))
```

---
In the following scenario, the DeepSeek-Coder-6.7B model effectively calls a class **IrisClassifier** and its member function from the `model.py` file, and also utilizes functions from the `utils.py` file, to correctly complete the **main** function in the `main.py` file for model training and evaluation.

![Completion GIF](pictures/completion_demo.gif)

### 5. How to Fine-tune DeepSeek-Coder

We provide script `finetune/finetune_deepseekcoder.py` for users to finetune our models on downstream tasks.

The script supports the training with [DeepSpeed](https://github.com/microsoft/DeepSpeed). You need install required packages by:

```bash
pip install -r finetune/requirements.txt
```

Please follow [Sample Dataset Format](https://huggingface.co/datasets/nickrosh/Evol-Instruct-Code-80k-v1) to prepare your training data.
Each line is a json-serialized string with two required fields `instruction` and `output`.

After data preparation, you can use the sample shell script to finetune `deepseek-ai/deepseek-coder-6.7b-instruct`. 
Remember to specify `DATA_PATH`, `OUTPUT_PATH`.
And please choose appropriate hyper-parameters(e.g., `learning_rate`, `per_device_train_batch_size`) according to your scenario.

```bash
DATA_PATH="<your_data_path>"
OUTPUT_PATH="<your_output_path>"
MODEL="deepseek-ai/deepseek-coder-6.7b-instruct"

cd finetune && deepspeed finetune_deepseekcoder.py \
    --model_name_or_path $MODEL_PATH \
    --data_path $DATA_PATH \
    --output_dir $OUTPUT_PATH \
    --num_train_epochs 3 \
    --model_max_length 1024 \
    --per_device_train_batch_size 16 \
    --per_device_eval_batch_size 1 \
    --gradient_accumulation_steps 4 \
    --evaluation_strategy "no" \
    --save_strategy "steps" \
    --save_steps 100 \
    --save_total_limit 100 \
    --learning_rate 2e-5 \
    --warmup_steps 10 \
    --logging_steps 1 \
    --lr_scheduler_type "cosine" \
    --gradient_checkpointing True \
    --report_to "tensorboard" \
    --deepspeed configs/ds_config_zero3.json \
    --bf16 True
```

### 6. Detailed Evaluation Results

The reproducible code for the following evaluation results can be found in the [Evaluation](https://github.com/deepseek-ai/deepseek-coder/tree/main/Evaluation) directory.
#### 1) Multilingual HumanEval Benchmark
![HumanEval](pictures/HumanEval.png)

#### 2) MBPP Benchmark
<img src="pictures/MBPP.png" alt="MBPP" width="40%">

#### 3) DS-1000 Benchmark
![DS-1000](pictures/DS-1000.png)

#### 4) Program-Aid Math Reasoning Benchmark
![Math](pictures/Math.png)

### Installation and Setup

To set up the environment for DeepSeek-Coder, we provide a convenient setup script that installs all necessary dependencies and checks for required datasets.

#### Quick Start

**For Windows:**
```bat
setup.bat
```

**For Linux/macOS:**
```bash
chmod +x setup.sh
./setup.sh
```

The setup script will:
1. Check your system environment and CUDA availability
2. Install all required dependencies
3. Check for evaluation datasets
4. Provide usage instructions

#### Advanced Options

You can customize the setup process with the following options:

```bash
# Skip dependency installation
setup.py --skip-deps      

# Only install specific dependencies
setup.py --eval-only      # Only evaluation dependencies
setup.py --finetune-only  # Only fine-tuning dependencies
setup.py --demo-only      # Only demo dependencies

# Virtual environment management
setup.py --create-venv    # Create a virtual environment
setup.py --venv-name NAME # Specify virtual environment name

# Testing and caching
setup.py --test-model     # Download and test a small model
setup.py --setup-model-cache # Set up the model cache directory
```

#### System Requirements

- **Python**: 3.8 - 3.11
- **RAM**: Minimum 16GB, 32GB+ recommended for larger models
- **GPU**: NVIDIA GPU with 12GB+ VRAM for base models, 24GB+ for 33B model
- **Disk Space**: 20GB+ for code and datasets, 100GB+ recommended including model cache

#### Manual Installation

If you prefer to install dependencies manually, refer to the requirements.txt files in the repository:
```bash
# Base dependencies
pip install -r requirements.txt

# Fine-tuning dependencies
pip install -r finetune/requirements.txt

# Demo dependencies
pip install -r demo/requirements.txt

# For specific evaluation tasks
pip install -r Evaluation/HumanEval/requirements.txt
pip install -r Evaluation/MBPP/requirements.txt
pip install -r Evaluation/PAL-Math/requirements.txt
pip install -r Evaluation/DS-1000/requirements.txt
```

#### Special Dependencies

For DeepSpeed installation (for fine-tuning):
```bash
pip install deepspeed --no-deps
pip install triton ninja packaging
```

#### Quick Setup

For a comprehensive installation of all dependencies at once:

```bat
install_requirements.bat
```

This will install all required dependencies for the core functionality, evaluations, demos, and fine-tuning (except DeepSpeed which requires special installation).

Alternative quick installation using the consolidated requirements file:

```bash
pip install -r une/requirements.txt
```

### Project Structure

The DeepSeek-Coder repository is organized as follows:

```
DeepSeek-Coder/
├── demo/                     # Interactive demo applications
├── docker/                   # Docker setup files
├── Evaluation/               # Evaluation benchmarks and tools
│   ├── DS-1000/              # DS-1000 benchmark
│   ├── HumanEval/            # HumanEval benchmark
│   ├── MBPP/                 # MBPP benchmark
│   └── PAL-Math/             # PAL-Math reasoning benchmark
├── finetune/                 # Fine-tuning scripts and utilities
│   ├── configs/              # DeepSpeed and training configs
│   └── data/                 # Sample fine-tuning data
├── implementation/           # Core model implementation
│   ├── legal_scraping/       # Legal data scraping components
│   └── model/                # Model architecture components
├── logs/                     # Application logs
├── models/                   # Model weights directory
├── pictures/                 # Documentation images
├── scripts/                  # Utility scripts
│   ├── download_model.py     # Model downloading script
│   ├── entrypoint.sh         # Docker entrypoint script
│   └── init_db.py            # Database initialization script
├── utils/                    # Utility modules
├── .dockerignore             # Docker ignore file
├── .gitignore                # Git ignore file
├── app.py                    # Main application entry point
├── docker-compose.yml        # Docker Compose configuration
├── Dockerfile                # Docker build file
├── LICENSE-CODE              # License for code
├── LICENSE-MODEL             # License for model weights
├── README.md                 # Project documentation
├── requirements.txt          # Python dependencies
├── setup.bat                 # Windows setup script
└── setup.sh                  # Linux/macOS setup script
```

### Docker Setup

This project includes a comprehensive Docker setup for both development and production use.

#### Prerequisites

- Docker and Docker Compose
- NVIDIA Docker runtime (for GPU support)
- At least 16GB RAM (32GB recommended)
- NVIDIA GPU with CUDA support (for optimal performance)

#### Quick Start

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/DeepSeek-Coder.git
   cd DeepSeek-Coder
   ```

2. Start the services with Docker Compose:
   ```bash
   docker-compose up -d
   ```

3. Access the API at http://localhost:8000

#### Configuration Options

You can configure the environment using these variables:

- `MODEL_SIZE`: Choose between `base` (6.7B parameters) or `large` (33B parameters)
- `CUDA_VISIBLE_DEVICES`: Specify which GPUs to use
- `PORT`: Change the default port (default: 8000)
- `LOG_LEVEL`: Set logging verbosity (`DEBUG`, `INFO`, `WARNING`, `ERROR`)

Example:
```bash
MODEL_SIZE=large PORT=9000 docker-compose up -d
```

#### Docker Commands

- Run API server: `docker-compose run deepsoul api`
- Run background worker: `docker-compose run deepsoul worker`
- Open interactive shell: `docker-compose run deepsoul shell`
- View logs: `docker-compose logs -f deepsoul`
- Stop services: `docker-compose down`

#### Available Services

- **deepsoul**: The main AI service
- **elasticsearch**: For knowledge storage and retrieval
- **kibana**: For visualizing stored data (available at http://localhost:5601)
- **jupyter**: (Optional) JupyterLab for interactive development

#### Persistent Storage

Data is stored in Docker volumes for persistence:

- `./data`: Application data
- `./models`: Downloaded model weights
- `./logs`: Application logs
- `esdata`: Elasticsearch data

### Deployment Guide

#### Cloud Deployment

##### AWS Deployment

1. **EC2 Setup with GPU Support**:
   - Launch an EC2 instance with GPU support (e.g., p3.2xlarge or g4dn.xlarge)
   - Use the Deep Learning AMI (Amazon Linux 2) which comes with CUDA pre-installed
   - Ensure security groups allow the necessary ports (8000 for API, 5601 for Kibana)

   ```bash
   # Install Docker and Docker Compose
   sudo amazon-linux-extras install docker
   sudo service docker start
   sudo usermod -a -G docker ec2-user
   sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
   sudo chmod +x /usr/local/bin/docker-compose
   
   # Install NVIDIA Container Toolkit
   distribution=$(. /etc/os-release;echo $ID$VERSION_ID)
   curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -
   curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list
   sudo apt-get update && sudo apt-get install -y nvidia-container-toolkit
   sudo systemctl restart docker
   ```

2. **Deploy Using Docker**:
   ```bash
   git clone https://github.com/yourusername/DeepSeek-Coder.git
   cd DeepSeek-Coder
   MODEL_SIZE=base docker-compose up -d
   ```

##### Azure Deployment

1. **Create an Azure VM with NVIDIA GPU**:
   - Use NC-series or ND-series VMs with NVIDIA GPUs
   - Deploy using a Data Science VM image with CUDA preinstalled

2. **Set Up Docker**:
   ```bash
   # Install Docker and NVIDIA Docker runtime
   sudo apt-get update
   sudo apt-get install -y docker.io
   sudo systemctl start docker
   sudo systemctl enable docker
   
   # Install Docker Compose
   sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
   sudo chmod +x /usr/local/bin/docker-compose
   
   # Setup NVIDIA Container Toolkit
   distribution=$(. /etc/os-release;echo $ID$VERSION_ID)
   curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -
   curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list
   sudo apt-get update
   sudo apt-get install -y nvidia-container-toolkit
   sudo systemctl restart docker
   ```

#### Kubernetes Deployment

For large-scale deployments, Kubernetes offers better scalability and management capabilities:

1. **Create a Kubernetes ConfigMap**:
   ```yaml
   # configmap.yaml
   apiVersion: v1
   kind: ConfigMap
   metadata:
     name: deepseek-config
   data:
     MODEL_SIZE: "base"
     LOG_LEVEL: "INFO"
     ELASTICSEARCH_HOST: "elasticsearch:9200"
   ```

2. **Create GPU-enabled Deployment**:
   ```yaml
   # deployment.yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: deepseek-coder
   spec:
     replicas: 2
     selector:
       matchLabels:
         app: deepseek-coder
     template:
       metadata:
         labels:
           app: deepseek-coder
       spec:
         containers:
         - name: deepseek-coder
           image: your-registry/deepseek-coder:latest
           ports:
           - containerPort: 8000
           envFrom:
           - configMapRef:
               name: deepseek-config
           resources:
             limits:
               nvidia.com/gpu: 1
           volumeMounts:
           - name: models-volume
             mountPath: /app/models
           - name: data-volume
             mountPath: /app/data
         volumes:
         - name: models-volume
           persistentVolumeClaim:
             claimName: models-pvc
         - name: data-volume
           persistentVolumeClaim:
             claimName: data-pvc
   ```

3. **Create a Service**:
   ```yaml
   # service.yaml
   apiVersion: v1
   kind: Service
   metadata:
     name: deepseek-coder
   spec:
     selector:
       app: deepseek-coder
     ports:
     - port: 8000
       targetPort: 8000
     type: LoadBalancer
   ```

4. **Apply the configurations**:
   ```bash
   kubectl apply -f configmap.yaml
   kubectl apply -f deployment.yaml
   kubectl apply -f service.yaml
   ```

#### Monitoring and Logging

For production deployments, implement monitoring and logging:

1. **Prometheus and Grafana** for metrics:
   - Add Prometheus annotations to your services
   - Deploy Grafana with dashboards for GPU utilization and service metrics

2. **ELK Stack** for centralized logging:
   - Configure Filebeat to collect container logs
   - Set up Elasticsearch for storage and Kibana for visualization

3. **Health Checks**:
   - The Docker container includes a health check endpoint at `/health`
   - Use Kubernetes liveness and readiness probes to ensure service availability

### Troubleshooting

#### Common Issues and Solutions

##### CUDA-related Problems

**Issue**: "CUDA out of memory" errors
**Solution**: 
- Reduce batch size in the configuration
- Use a smaller model variant
- Check if other processes are using GPU memory
- Use `PYTORCH_CUDA_ALLOC_CONF=max_split_size_mb:128` environment variable

**Issue**: "CUDA not available" errors
**Solution**:
- Verify NVIDIA drivers are installed: `nvidia-smi`
- Check CUDA installation: `nvcc --version`
- Ensure PyTorch was installed with CUDA support: `python -c "import torch; print(torch.cuda.is_available())"`

##### Docker Issues

**Issue**: Container fails to start
**Solution**:
- Check logs: `docker-compose logs deepsoul`
- Verify Docker has access to GPUs: `docker run --gpus all nvidia/cuda:11.6.2-base-ubuntu20.04 nvidia-smi`
- Ensure sufficient disk space for images and volumes

**Issue**: Elasticsearch fails to start
**Solution**:
- Set `vm.max_map_count` on the host: `sudo sysctl -w vm.max_map_count=262144`
- Check available disk space
- Verify port 9200 is not in use by another service

##### Model Loading Issues

**Issue**: "Failed to download model" errors
**Solution**:
- Check network connectivity to HuggingFace
- Set `HF_HOME` environment variable to a directory with sufficient space
- Try downloading manually using `huggingface-cli`

**Issue**: Model loading very slow
**Solution**:
- The first load caches the model; subsequent loads will be faster
- Consider using a smaller model size for testing
- For production, use model quantization options

##### Memory Issues

**Issue**: System runs out of memory
**Solution**:
- Use swap space if RAM is limited
- Use model quantization (see Q&A section)
- Implement gradient accumulation for training
- For inference, use smaller batch sizes and offloading techniques

##### Integration Issues

**Issue**: API returns 504 Gateway Timeout
**Solution**:
- Increase timeout settings in your proxy/gateway
- Model generation can take time for complex prompts
- Consider implementing asynchronous processing for long-running tasks

#### Debugging Tips

1. **Enable verbose logging**:
   ```bash
   LOG_LEVEL=DEBUG docker-compose up -d
   ```

2. **Inspect containers**:
   ```bash
   docker-compose exec deepsoul bash
   ```

3. **Check GPU usage**:
   ```bash
   docker-compose exec deepsoul nvidia-smi
   ```

4. **Test the model in isolation**:
   ```bash
   docker-compose run deepsoul python -c "from transformers import AutoTokenizer, AutoModelForCausalLM; tokenizer = AutoTokenizer.from_pretrained('deepseek-ai/deepseek-coder-6.7b-base', trust_remote_code=True); print('Tokenizer loaded successfully')"
   ```

### API Documentation

DeepSeek-Coder provides a RESTful API for code generation, completion, and chat functionalities.

#### API Endpoints

##### Code Completion API

**Endpoint**: `POST /api/v1/completion`

**Request Body**:
```json
{
  "prompt": "def fibonacci(n):",
  "max_tokens": 100,
  "temperature": 0.7,
  "top_p": 0.95,
  "language": "python"
}
```

**Response**:
```json
{
  "id": "cmpl-abc123",
  "object": "text_completion",
  "created": 1677858242,
  "model": "deepseek-coder-6.7b-base",
  "choices": [
    {
      "text": "    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    else:\n        fib = [0, 1]\n        for i in range(2, n):\n            fib.append(fib[i-1] + fib[i-2])\n        return fib",
      "index": 0,
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 5,
    "completion_tokens": 95,
    "total_tokens": 100
  }
}
```

##### Code Insertion API

**Endpoint**: `POST /api/v1/insertion`

**Request Body**:
```json
{
  "prefix": "def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[0]\n    left = []\n    right = []",
  "suffix": "        if arr[i] < pivot:\n            left.append(arr[i])\n        else:\n            right.append(arr[i])\n    return quick_sort(left) + [pivot] + quick_sort(right)",
  "max_tokens": 50
}
```

**Response**:
```json
{
  "id": "ins-xyz789",
  "object": "text_insertion",
  "created": 1677858350,
  "model": "deepseek-coder-6.7b-base",
  "choices": [
    {
      "text": "    for i in range(1, len(arr)):",
      "index": 0,
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 60,
    "completion_tokens": 10,
    "total_tokens": 70
  }
}
```

##### Chat API

**Endpoint**: `POST /api/v1/chat`

**Request Body**:
```json
{
  "messages": [
    {"role": "user", "content": "Write a function that calculates the factorial of a number in Python."}
  ],
  "max_tokens": 300,
  "temperature": 0.7
}
```

**Response**:
```json
{
  "id": "chat-def456",
  "object": "chat.completion",
  "created": 1677858500,
  "model": "deepseek-coder-6.7b-instruct",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "Sure, here's a Python function to calculate the factorial of a number:\n\n```python\ndef factorial(n):\n    \"\"\"\n    Calculate the factorial of a non-negative integer n.\n    \n    Args:\n        n: A non-negative integer\n        \n    Returns:\n        The factorial of n (n!)\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n# Example usage\nprint(factorial(5))  # Output: 120\n```\n\nThis function uses recursion to calculate the factorial. For very large numbers, you might want to use an iterative approach to avoid stack overflow."
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 15,
    "completion_tokens": 250,
    "total_tokens": 265
  }
}
```

#### Authentication

For production use, secure your API with authentication:

1. **API Key Authentication**:
   - Include your API key in the headers:
   ```
   Authorization: Bearer YOUR_API_KEY
   ```

2. **Rate Limiting**:
   - Default rate limit: 100 requests per hour per API key
   - Higher limits available for enterprise users

#### Client Libraries

Official client libraries for easy integration:

**Python Client**:
```python
from deepseek_client import DeepSeekClient

client = DeepSeekClient(api_key="YOUR_API_KEY")

# Code completion
completion = client.completion.create(
    prompt="def binary_search(arr, target):",
    max_tokens=200,
    temperature=0.7
)
print(completion.choices[0].text)

# Chat
chat_response = client.chat.create(
    messages=[
        {"role": "user", "content": "Explain how to implement merge sort in JavaScript"}
    ],
    max_tokens=500
)
print(chat_response.choices[0].message.content)
```

### Security Considerations

#### API Security

1. **API Key Management**:
   - Rotate API keys regularly
   - Use environment variables to store API keys
   - Never hardcode API keys in client-side code

2. **Rate Limiting and Quotas**:
   - Set appropriate rate limits to prevent abuse
   - Monitor API usage for suspicious patterns

3. **Input Validation**:
   - Validate and sanitize all user inputs
   - Implement request size limits to prevent DoS attacks

#### Docker Security

1. **Container Hardening**:
   - Run containers as non-root users (implemented in the Dockerfile)
   - Use minimal base images to reduce attack surface
   - Keep images updated with security patches

2. **Secrets Management**:
   - Use Docker secrets or environment variables for sensitive data
   - Never build secrets into Docker images

#### Model Security

1. **Prompt Injection Protection**:
   - Implement guardrails to detect and prevent prompt injection attacks
   - Sanitize user inputs before passing to the model

2. **Output Filtering**:
   - Filter model outputs for potentially harmful content
   - Implement content policies based on your use case

### 7. Q&A

#### Could You Provide the tokenizer.model File for Model Quantization?

DeepSeek Coder utilizes the [HuggingFace Tokenizer](https://huggingface.co/docs/tokenizers/index) to implement the Bytelevel-BPE algorithm, with specially designed pre-tokenizers to ensure optimal performance. Currently, there is no direct way to convert the tokenizer into a SentencePiece tokenizer. We are contributing to the open-source quantization methods facilitate the usage of HuggingFace Tokenizer.

##### GGUF(llama.cpp)

We have submitted a [PR](https://github.com/ggerganov/llama.cpp/pull/4070) to the popular quantization repository [llama.cpp](https://github.com/ggerganov/llama.cpp) to fully support all HuggingFace pre-tokenizers, including ours.

While waiting for the PR to be merged, you can generate your GGUF model using the following steps:

```bash
git clone https://github.com/DOGEwbx/llama.cpp.git
cd llama.cpp
git checkout regex_gpt2_preprocess
# set up the environment according to README
make
python3 -m pip install -r requirements.txt
# generate GGUF model
python convert-hf-to-gguf.py <MODEL_PATH> --outfile <GGUF_PATH> --model-name deepseekcoder
# use q4_0 quantization as an example
./quantize <GGUF_PATH> <OUTPUT_PATH> q4_0
./main -m <OUTPUT_PATH> -n 128 -p <PROMPT>
```
##### GPTQ(exllamav2)

`UPDATE:`[exllamav2](https://github.com/turboderp/exllamav2) has been able to support Huggingface Tokenizer. Please pull the latest version and try out.

Remember to set RoPE scaling to 4 for correct output, more discussion could be found in this [PR](https://github.com/turboderp/exllamav2/pull/189).

#### How to use the deepseek-coder-instruct to complete the code?

Although the deepseek-coder-instruct models are not specifically trained for code completion tasks during supervised fine-tuning (SFT), they retain the capability to perform code completion effectively. To enable this functionality, you simply need to adjust the eos_token_id parameter. Set the eos_token_id to 32014, as opposed to its default value of 32021 in the deepseek-coder-instruct configuration. This modification prompts the model to recognize the end of a sequence differently, thereby facilitating code completion tasks.


### 8. Resources
[awesome-deepseek-coder](https://github.com/deepseek-ai/awesome-deepseek-coder) is a curated list of open-source projects related to DeepSeek Coder.

### 9. License
This code repository is licensed under the MIT License. The use of DeepSeek Coder models is subject to the Model License. DeepSeek Coder supports commercial use.

See the [LICENSE-CODE](LICENSE-CODE) and [LICENSE-MODEL](LICENSE-MODEL) for more details.

### 10. Citation
```
@misc{deepseek-coder,
  author = {Daya Guo, Qihao Zhu, Dejian Yang, Zhenda Xie, Kai Dong, Wentao Zhang, Guanting Chen, Xiao Bi, Y. Wu, Y.K. Li, Fuli Luo, Yingfei Xiong, Wenfeng Liang},
  title = {DeepSeek-Coder: When the Large Language Model Meets Programming -- The Rise of Code Intelligence},
  journal = {CoRR},
  volume = {abs/2401.14196},
  year = {2024},
  url = {https://arxiv.org/abs/2401.14196},
}
```

### 11. Contact

If you have any questions, please raise an issue or contact us at [service@deepseek.com](mailto:service@deepseek.com).

## Docker Setup

This project includes a comprehensive Docker setup for both development and production use.

### Prerequisites

- Docker and Docker Compose
- NVIDIA Docker runtime (for GPU support)
- At least 16GB RAM (32GB recommended)
- NVIDIA GPU with CUDA support (for optimal performance)

### Quick Start

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/DeepSeek-Coder.git
   cd DeepSeek-Coder
   ```

2. Start the services with Docker Compose:
   ```bash
   docker-compose up -d
   ```

3. Access the API at http://localhost:8000

### Configuration Options

You can configure the environment using these variables:

- `MODEL_SIZE`: Choose between `base` (6.7B parameters) or `large` (33B parameters)
- `CUDA_VISIBLE_DEVICES`: Specify which GPUs to use
- `PORT`: Change the default port (default: 8000)
- `LOG_LEVEL`: Set logging verbosity (`DEBUG`, `INFO`, `WARNING`, `ERROR`)

Example:
```bash
MODEL_SIZE=large PORT=9000 docker-compose up -d
```

### Docker Commands

- Run API server: `docker-compose run deepsoul api`
- Run background worker: `docker-compose run deepsoul worker`
- Open interactive shell: `docker-compose run deepsoul shell`
- View logs: `docker-compose logs -f deepsoul`
- Stop services: `docker-compose down`

### Available Services

- **deepsoul**: The main AI service
- **elasticsearch**: For knowledge storage and retrieval
- **kibana**: For visualizing stored data (available at http://localhost:5601)
- **jupyter**: (Optional) JupyterLab for interactive development

### Persistent Storage

Data is stored in Docker volumes for persistence:

- `./data`: Application data
- `./models`: Downloaded model weights
- `./logs`: Application logs
- `esdata`: Elasticsearch data
