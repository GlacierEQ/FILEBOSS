#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  Tool,
} from "@modelcontextprotocol/sdk/types.js";

// Type definitions
interface Memory {
  text: string;
  metadata?: {
    text: string;
    createdAt: string;
    bucketId?: number;
    bucketName?: string;
  };
}

interface Bucket {
  id: string;
  name: string;
  description?: string;
  memoryCount: number;
}

interface ApiResponse<T> {
  data?: T;
  error?: string;
}

class MemoryPluginClient {
  private baseUrl = "https://www.memoryplugin.com/api";
  private headers: { Authorization: string; "Content-Type": string };

  constructor(token: string) {
    this.headers = {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
    };
  }

  private async fetchApi<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<ApiResponse<T>> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        headers: {
          ...this.headers,
          ...options.headers,
        },
      });

      if (!response.ok) {
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      return { data };
    } catch (error) {
      return {
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  async storeMemory(text: string, bucketId?: number): Promise<ApiResponse<{ done: string }>> {
    return this.fetchApi("/memory", {
      method: "POST",
      body: JSON.stringify({ text, bucketId }),
    });
  }

  async getMemories(params: {
    query?: string;
    all?: boolean;
    latest?: boolean;
    count?: number;
  }): Promise<ApiResponse<Memory[]>> {
    const searchParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        searchParams.append(key, String(value));
      }
    });
    return this.fetchApi(`/v2/memory?${searchParams}`);
  }

  async getBuckets(): Promise<ApiResponse<Bucket[]>> {
    return this.fetchApi("/buckets");
  }

  async createBucket(name: string): Promise<ApiResponse<{ message: string }>> {
    return this.fetchApi("/buckets", {
      method: "POST",
      body: JSON.stringify({ name }),
    });
  }

  async getMemoriesAndBuckets(params: {
    bucketId?: number;
    count?: number;
    all?: boolean;
    latest?: boolean;
    query?: string;
  }): Promise<ApiResponse<{ memories: Memory[]; buckets: Bucket[] }>> {
    const searchParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined) {
        searchParams.append(key, String(value));
      }
    });
    return this.fetchApi(`/v2/memory?${searchParams}`);
  }
}

// MCP Server implementation
const server = new Server(
  {
    name: "memory-plugin-server",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

let memoryClient: MemoryPluginClient;

// Tool definitions
const tools: Tool[] = [
  {
    name: "store_memory",
    description: "Store a new memory with optional bucket assignment",
    inputSchema: {
      type: "object",
      properties: {
        text: {
          type: "string",
          description: "The memory text to store",
        },
        bucketId: {
          type: "number",
          description: "Optional bucket ID to store the memory in",
        },
      },
      required: ["text"],
    },
  },
  {
    name: "get_memories",
    description: "Query or retrieve memories with various filters",
    inputSchema: {
      type: "object",
      properties: {
        query: {
          type: "string",
          description: "Optional search query",
        },
        all: {
          type: "boolean",
          description: "Whether to fetch all memories",
        },
        latest: {
          type: "boolean",
          description: "Whether to fetch only latest memories",
        },
        count: {
          type: "number",
          description: "Number of memories to retrieve (default: 10)",
        },
      },
    },
  },
  {
    name: "list_buckets",
    description: "List all available memory buckets",
    inputSchema: {
      type: "object",
      properties: {},
    },
  },
  {
    name: "create_bucket",
    description: "Create a new memory bucket",
    inputSchema: {
      type: "object",
      properties: {
        name: {
          type: "string",
          description: "Name for the new bucket",
        },
      },
      required: ["name"],
    },
  },
  {
    name: "get_memories_and_buckets",
    description: "Get both memories and buckets in a single request with optional filtering",
    inputSchema: {
      type: "object",
      properties: {
        bucketId: {
          type: "number",
          description: "Optional bucket ID to filter memories",
        },
        count: {
          type: "number",
          description: "Number of memories to retrieve (default: 10)",
        },
        all: {
          type: "boolean",
          description: "Whether to fetch all memories",
        },
        latest: {
          type: "boolean",
          description: "Whether to fetch only latest memories",
        },
        query: {
          type: "string",
          description: "Optional search query",
        },
      },
    },
  },
];

// Request handlers
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools,
}));

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (!args) {
    throw new Error("No arguments provided");
  }

  try {
    switch (name) {
      case "store_memory": {
        const { text, bucketId } = args as { text: string; bucketId?: number };
        const result = await memoryClient.storeMemory(text, bucketId);
        return {
          content: [
            {
              type: "text",
              text: result.error ?? "Memory stored successfully",
            },
          ],
          isError: !!result.error,
        };
      }

      case "get_memories": {
        const { query, all, latest, count } = args as {
          query?: string;
          all?: boolean;
          latest?: boolean;
          count?: number;
        };
        const result = await memoryClient.getMemories({ query, all, latest, count });
        return {
          content: [
            {
              type: "text",
              text: result.error ?? JSON.stringify(result.data, null, 2),
            },
          ],
          isError: !!result.error,
        };
      }

      case "list_buckets": {
        const result = await memoryClient.getBuckets();
        return {
          content: [
            {
              type: "text",
              text: result.error ?? JSON.stringify(result.data, null, 2),
            },
          ],
          isError: !!result.error,
        };
      }

      case "create_bucket": {
        const { name } = args as { name: string };
        const result = await memoryClient.createBucket(name);
        return {
          content: [
            {
              type: "text",
              text: result.error ?? `Bucket "${name}" created successfully`,
            },
          ],
          isError: !!result.error,
        };
      }

      case "get_memories_and_buckets": {
        const params = args as {
          bucketId?: number;
          count?: number;
          all?: boolean;
          latest?: boolean;
          query?: string;
        };
        const result = await memoryClient.getMemoriesAndBuckets(params);
        return {
          content: [
            {
              type: "text",
              text: result.error ?? JSON.stringify(result.data, null, 2),
            },
          ],
          isError: !!result.error,
        };
      }

      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    return {
      content: [
        {
          type: "text",
          text: error instanceof Error ? error.message : String(error),
        },
      ],
      isError: true,
    };
  }
});

// Server startup
async function main() {
  const token = process.env.MEMORY_PLUGIN_TOKEN;
  
  if (!token) {
    throw new Error("MEMORY_PLUGIN_TOKEN environment variable is required");
  }

  memoryClient = new MemoryPluginClient(token);
  
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("MemoryPlugin MCP Server running on stdio");
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});